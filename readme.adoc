= j'bang - Having fun with Java scripting
:idprefix:
:idseparator: -
:toc: macro
ifndef::env-github[:icons: font]
ifdef::env-github[]
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

image:https://img.shields.io/github/release/jbangdev/jbang.svg[Release,link=https://github.com/jbangdev/jbang/releases]
image:https://github.com/jbangdev/jbang/workflows/ci-build/badge.svg[Build Status,link=https://github.com/jbangdev/jbang/actions]
image:https://www.eclipse.org/che/contribute.svg[Che, link=https://che.openshift.io/f?url=https://github.com/jbangdev/jbang]
image:https://img.shields.io/badge/Gitpod-Workspace-blue?logo=gitpodp[Gitpod, link=https://gitpod.io/#https://github.com/jbangdev/jbang]

image:images/jbang_logo.svg[JBang Logo, title="JBang Logo"]

== Intro

Want to learn, explore or use Java instantly without setup ?

Do you like Java but use python, groovy, kotlin or similar languages for your scripts ?

Ever tried out Java 11+ support for running `.java` files directly in your shell but felt it was a bit too cumbersome ?

Then try `jbang` which lets you do this:

image:https://asciinema.org/a/AVwA19yijKRNKEO0bJENN2ME3.svg[link=https://asciinema.org/a/AVwA19yijKRNKEO0bJENN2ME3?autoplay=true&speed=2&theme=solarized-dark]

[source, bash]
----
$ jbang init --template=cli hello.java
$ jbang hello.java Max!
[jbang] Resolving dependencies...
[jbang]     Resolving info.picocli:picocli:4.5.0...Done
[jbang] Dependencies resolved
[jbang] Building jar...
Hello Max!
$ jbang hello.java -h
Usage: hello [-hV] <greeting>
hello made with jbang
      <greeting>   The greeting to print
  -h, --help       Show this help message and exit.
  -V, --version    Print version information and exit.
----

Instant cli app generated built using java and picocli as a dependency that was fetched as needed for the compilation and execution.

toc::[]

== Features

* `.java` Scripting for Java 8 and upwards
* `.jsh` via JShell from Java 9 and upwards
* Works on icon:windows[] Windows, icon:apple[] OSX and icon:linux[] Linux
* Install using SDKMan (icon:apple[]/icon:linux[]), Homebrew (icon:apple[]), Chocolatey (icon:windows[]) or Scoop (icon:windows[])
* Dependency declarations using `//DEPS <gav>` for automatic dependency resolution
* Control compile and runtime options with `//JAVAC_OPTIONS <flags>` and `//JAVA_OPTIONS <flags>`
* Compiled jar and Dependency resolution caching
* (EXPERIMENTAL) native-image generation (`--native`)
* Launch with debug enabled for instant debugging from your favorite IDE
* Transparent launch of JavaFX Applications on Java 8 and higher
* Can be used for writing plugins to other cli's like `kubectl`
* Init templates to get started easily (`jbang init -t cli hello.java`)
* Generate gradle and IDE config with dependencies for easy editing in your favorite IDE (`jbang edit myfile.java`)
* (PLANNED) Lookup dependencies with a short-hand name, i.e. `// DEPS log4j:1.2+,picocli` for quick getting started.

To use it simply install `jbang` and run `jbang yourscript.java`

== Requirements

Minimum Java 8, Recommended: Java 11+

Tested and verified to use on OSX, Linux and Windows (incl. command, cygwin and mingw shells).

== Installation

To use `jbang` Java 8 is the minimum required version, however Java 11 or higher is recommended.


=== SDKMan icon:linux[] / icon:apple[]

To install both java and `jbang` we recommend https://sdkman.io[sdkman] on Linux and OSX.

[source, bash]
----
curl -s "https://get.sdkman.io" | bash # <.>
source ~/.bash_profile # <.>

sdk install java # <.>
----

Once Java is installed and ready, you install `jbang` with

[source, bash]
----
sdk install jbang
----

To test your installation run:

[source, bash]
----
jbang --help
----

This should print out usage information.

To update run:

[source]
----
sdk update jbang
----

=== Chocolatey icon:windows[]

On Windows you can install both `java` and jbang` with https://chocolatey.org[Chocolatey].

From a command prompt with enough rights to install with choco:

  choco install jdk11

Once Java in installed run:

  choco install jbang

To upgrade to latest version:

  choco upgrade jbang

The latest package will be published to https://chocolatey.org/packages/jbang[jbang choco package page],
it might be a bit delayed as the review is still manual. In case the default version is not
the latest you can see the https://chocolatey.org/packages/jbang/#versionhistory[version list] and install specific version using:

  choco install jbang --version=<version number>

=== Scoop icon:windows[]

On Windows you can also install `jbang` with https://scoop.sh[Scoop].

[source, bash]
----
scoop bucket add jbangdev https://github.com/jbangdev/scoop-bucket
scoop install jbang
----

To upgrade to latest version:

  scoop update jbang

=== Homebrew icon:apple[]

On OSX you can install 'java' and `jbang` with https://brew.sh[Homebrew] using custom taps.

To install Java 11:

[source, bash]
----
brew tap AdoptOpenJDK/openjdk
brew cask install adoptopenjdk11
----

Once Java is installed you can use brew with https://github.com/jbangdev/homebrew-tap/[jbangdev/tap] to get `jbang`:

  brew install jbangdev/tap/jbang

To upgrade to latest version:

  brew upgrade jbangdev/tap/jbang

==== Installing older versions via Homebrew

If you encounter an issue in `jbang` that is not present in an older version,
you can revert back to that older version following these steps:

. Find the commit id for the version to revert to (e.g. `0.8.1`).
+
[source]
----
$ cd "$(brew --repo jbangdev/tap)"
$ git log master -- Formula/jbang.rb
...
commit fd70f1bc0a7f69d81cfb5b08a0d2bb698fbd01b2
Author: Max Rydahl Andersen <max@xam.dk>
Date:   Tue Jan 21 00:33:05 2020 +0000

    jbang v0.8.1
----

. Checkout the version.
+
[source,bash]
----
$ git checkout fd70f1bc0a7f69d81cfb5b08a0d2bb698fbd01b
----

. Unlink current `jbang` version.
+
[source,bash]
----
$ brew unlink jbang
Unlinking /usr/local/Cellar/jbang/0.13.2... 1 symlinks removed
----

. Install the older version.
+
[source,bash]
----
$ HOMEBREW_NO_AUTO_UPDATE=1 brew install jbang
...
üç∫  /usr/local/Cellar/jbang/0.8.1: 18 files, 2.9MB, built in 6 seconds
----

. Verify the version.
+
[source,bash]
----
$ jbang version
0.33.0
----

=== (Experimental) Linux packages icon:linux[]

WARNING: These builds are not fully automated yet thus might be slightly behind.

You can install rpm packages from https://copr.fedorainfracloud.org/coprs/maxandersen/jbang/[Fedora Copr]
by doing the following:

[source]
----
dnf copr enable maxandersen/jbang
dnf install jbang
----

The COPR currently includes builds from various versions of CentOS, Fedora, Mageia and OpenSuse.

=== Docker / GitHub Action icon:docker[]

You can run `jbang` via Docker:

[source, bash]
----
docker run -v `pwd`:/ws --workdir=/ws jbangdev/jbang-action helloworld.java
----

or if you prefer using Quay.io:

[source, bash]
----
docker run -v `pwd`:/ws --workdir=/ws quay.io/jbangdev/jbang-action helloworld.java
----

The same container images can be used with GitHub Actions, see https://github.com/jbangdev/jbang-action[jbang-action] for details.

=== Manual install

Unzip the https://github.com/jbangdev/jbang/releases/latest[latest binary release], add the `jbang-<version>/bin` folder to your `$PATH` and you are set.

=== Wrapper install

If you would like to have jbang available in a local directory and committed into a source code repository you akin to maven and gradle wrappers you can use the `wrapper` command.

If you have `jbang` alredy installed you call `jbang wrapper install` in a folder to install a local `jbang`
that will run out of that directory using `./jbang`. 


== Usage

A script is just a single `.java` file with a classic static main method or a `.jsh` file which will be passed to `jshell`.

Below is an (almost) minimal example you can save in `helloworld.java` or simply run `jbang init helloworld.java`:

[source,java]
----
///usr/bin/env jbang "$0" "$@" ; exit $? // <.>

class helloworld { // <.>

    public static void main(String[] args) {
        if(args.length==0) {
            System.out.println("Hello World!");
        } else {
            System.out.println("Hello " + args[0]);
        }
    }
}
----
<.> By using this `//` style instead of shebang `#!` you trick `bash`, `zsh` etc. to run this as a script while still being valid java code.
<.> A classname, can be anything when using `jbang` but to be valid java for most IDEs you'll want to name it the same as the source file.

Now to run this you can call it via `jbang`:

[source]
----
jbang helloworld.java
----

or if on Linux/OSX run it directly. If you created it manually you need to mark it as executable before running it.

[source]
----
chmod +x helloworld.java
./helloworld jbang!
----

[WARNING]
====
When no <<java-version,JDK version>> is available in the PATH, Jdk 11 will be downloaded by default to bootstrap jbang.
If your script requires a higher version and you don' want to download two jdk's, you can define an alternative default with `JBANG_DEFAULT_JAVA_VERSION` env variable.

 $ JBANG_DEFAULT_JAVA_VERSION=14 jbang my-script.java

Note that if JDK is found in the PATH, `JBANG_DEFAULT_JAVA_VERSION` will be ignored.
====

=== URLs from Trusted Sources

You can use `http(s):/` and `file:/` url's for input:.

[source]
----
jbang https://github.com/jbangdev/jbang/blob/master/examples/helloworld.java
----

For safety reasons jbang will not run arbitrary urls before you indicated you trust their source.
Thus when running the above for the first time you will see the following warning about the url not being a trusted source:

[source,bash]
----
[jbang] https://github.com/jbangdev/jbang/blob/master/examples/helloworld.java is not from a trusted source thus aborting.
If you trust the url to be safe to run are here a few suggestions:
Limited trust:
    jbang trust add https://github.com/jbangdev/jbang/
Trust all subdomains:
    jbang trust add *.github.com
Trust all sources (WARNING! disables url protection):
    jbang trust add "*"

For more control edit ~/.jbang/trusted-sources.json

[jbang] Run with --verbose for more details
----

To enable running it you need to mark that url or a sub part of it as a trusted source.
i.e. `jbang trust add https://github.com/jbangdev/jbang/` will tell `jbang` to trust anything with that base url.

You can see more in the comments of the `~/.jbang/trusted-sources.json`.

[TIP]
====
Sites such as github, gitlab, bitbucket, gist, twitter and carbon.now.sh jbang will try and extract the proper source rather than the raw html.
i.e. doing `jbang https://twitter.com/maxandersen/status/1266904846239752192 twitter!` is possible.
====

[TIP]
====
URL's will follow redirects. In case you need to use it with sites with self-signed/non-trusted certificates you can
if you trust the site use `--insecure`.
====

=== Build and run native image (Experimental)

There is support for using `native-image` from GraalVM project to produce a binary executable.

Since not all java libraries can automatically be built with `native-image` - especially if using reflection feature are considered highly experimental.

Just run `jbang --native helloworld.java` and `jbang` will use `native-image` from either `JAVA_HOME/bin` or `GRAALVM_HOME/bin` to
produce a native image binary.

[TIP]
====
If you use `--native` with picocli remember to add `info.picocli:picocli-codegen` as that will ensure it will actually work with `native-image`.
====


=== Using `.jsh` for `jshell`

There is support to run `.jsh` via `jshell`. The advantage of `jshell` is that you do not need to have a class or static main method.

Classic `jshell` does not support passing in arguments nor system properties, `jbang` does.

In the case of `.jsh` files `jbang` injects a startup script that declares a `String[] args` which will contain any passed in arguments,
and it sets any properties passed in as `-Dkey=value` as parameters to `jbang`.

That means you can run a script as `jbang -Dkey=value World helloworld.jsh` and retrieve arguments and properties as:

[source,java]
----
System.out.println("Hello " + (args.length>0?args[0]:"World")); // <.>
System.getProperty("key"); // <.>
----
<.> Line where `args` are accessible without previous declaration.
<.> System properties set when passed as `-D` arguments to `jbang`

The script will have the output:

 Hello World
 value


==== Running script from standard input

jbang can run scripts directly from standard input using `-` or `/dev/stdin` as input.

i.e.

`echo 'System.out.println("Hello World!");' | jbang -`

[TIP]
====
If you use `--interactive` `jbang` will let `jshell` enter into interactive/REPL mode. You can write `/exit` to leave this mode.
====

[TIP]
====
If your own code needs to handle chained pipes well it is recommended to add the following code:

[source,java]
----
import sun.misc.Signal;

if (!"Windows".equals(System.getProperty("os.name"))) {
    Signal.handle(new Signal("PIPE"), (final Signal sig) -> System.exit(1));
}
----

It will give a compiler warning as it is internal API; but for now it works.
====

=== Running ``.jar``'s (EXPERIMENTAL)

`jbang` will also run `.jar` files directly.

i.e. `jbang helloworld.jar` will run `helloworld.jar` if found on your local file system.

You can also run a `.jar` file referenced by a Maven coordinate, i.e.:

  jbang info.picocli:picocli-codegen:4.5.0

This will fetch the dependency stated and put the transitive dependencies on the classpath.

If you need to specify a main class you can do so by using `--main` i.e.

  jbang --main picocli.codegen.aot.graalvm.ReflectionConfigGenerator info.picocli:picocli-codegen:4.5.0

[TIP]
====
A side effect of running GAV as a jar, the GAV could also be a `.java` or `.jsh` file and it would be launched as a script instead of a jar.
No one would want to do that (right?) but now you know.
====

== Init templates

To get started you can run `jbang init helloworld.java` and a simple java class with a static main is generated.

Using `jbang init --template=cli helloworld.java` you get a more complete Hello World CLI using https://picocli.info/[picocli] as dependency.

== Declare dependencies

If you want to write real scripts you will want to use some java libraries.
To specify dependencies you use gradle-style locators or links to Git sources. Below are examples for `log4j`.

=== Using `//DEPS`

[source,java]
----
///usr/bin/env jbang "$0" "$@" ; exit $?
// <.>
//DEPS log4j:log4j:1.2.17

import static java.lang.System.out;

import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

import java.util.Arrays;

class classpath_example {

	static final Logger logger = Logger.getLogger(classpath_example.class);

	public static void main(String[] args) {
		BasicConfigurator.configure(); // <.>
		logger.info("Welcome to jbang");

		Arrays.asList(args).forEach(arg -> logger.warn("arg: " + arg));
		logger.info("Hello from Java!");
	}
}
----
<.> `//DEPS` must be placed at the start of line and can be one or more space separated dependencies.
<.> Minimal logging setup - required by log4j.

Now when you run this, the first time with no existing dependencies installed you should get an output like this:

[source]
----
$ ./classpath_example.java
[jbang] Resolving dependencies...
[jbang]     Resolving log4j:log4j:1.2.17...Done
[jbang] Dependencies resolved
0 [main] INFO classpath_example  - Welcome to jbang
1 [main] INFO classpath_example  - Hello from Java!
----

=== Using links to Git sources

Instead of gradle-style locators you can also use URLs to projects on GitHub, GitLab or BitBucket.
Links to those projects will then be converted to artifacts references on https://jitpack.io/[jitpack].
You can use links to the root of the project, to the root of a tag/release and to specific commits.

If the project you link to has multiple modules and you want only a specific module you can specify the
name of the module by appending `#name-of-module` to the URL.

And finally if the link you provide is to a specific branch of the project then you need to append
`#:SNAPSHOT` to the URL. (If you have both a branch and a module name then use `#name-of-module:SNAPSHOT`)

.Examples of links and their resulting locator:
|===
|Link | Locator
|https://github.com/jbangdev/jbang
|com.github.jbangdev:jbang:master-SNAPSHOT

|https://github.com/jbangdev/jbang/tree/v1.2.3
|com.github.jbangdev:jbang:v1.2.3

|https://github.com/jbangdev/jbang/tree/f1f34b031d2163e0cdc6f9a3725b59f47129c923[https://github.com/jbangdev/jbang/tree/f1f34b031...]
|com.github.jbangdev:jbang:f1f34b031d

|https://github.com/jbangdev/jbang#mymodule
|com.github.jbangdev.jbang:mymodule:master-SNAPSHOT

|https://github.com/jbangdev/jbang/tree/mybranch#:SNAPSHOT
|com.github.jbangdev:jbang:mybranch-SNAPSHOT

|https://github.com/jbangdev/jbang/tree/mybranch#mymodule:SNAPSHOT
|com.github.jbangdev.jbang.mymodule:mybranch-SNAPSHOT
|===

=== Offline mode

In case you prefer `jbang` to just fail-fast when dependencies cannot be found locally you can run `jbang` in offline mode using
`jbang -o` or `jbang --offline`. In this mode `jbang` will simply fail if dependencies have not been cached already.

=== Repositories

By default `jbang` uses https://jcenter.bintray.com/[jcenter] as its repository as it is a superset of Maven Central
and supposedly should be faster.

And if you are using the above mentioned URL dependencies https://jitpack.io[jitpack] will be added automatically as well.

If that is not sufficient for you or need some custom repo you can use `//REPOS id=repourl` to
state which repository URL to use.

For ease of use there are also a few shorthands to use popular commonly available repositories.

|===
|Short name | Description
|`mavencentral`
|Maven Central

|`jcenter`
|`https://jcenter.bintray.com/`

|`google`
|`https://maven.google.com/`

|`jitpack`
|`https://jitpack.io/`
|===

Following example enables use of Maven Central and add a custom `acme` repository.

[source,java]
----
//REPOS mavenCentral,acme=https://maven.acme.local/maven
----

[WARNING]
====
If you add any `//REPOS` lines `jbang` will no longer consult `jcenter` thus you need to explicitly add it if needed.
====

[TIP]
====
For secure authentication `jbang` will honor `~/.m2/settings-security.xml` for configuring
username/passwords.
====


=== Using `@Grab`

There is also support for using Groovy lang style `@Grab` syntax.

[source,java]
----
///usr/bin/env jbang "$0" "$@" ; exit $?

import static java.lang.System.out;

import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

import java.util.Arrays;

import groovy.lang.Grab; // <.>
import groovy.lang.Grapes;
import groovy.lang.GrabResolver;

@GrabResolver("mavenCentral") // <.>
@GrabResolver(name='acme', root='https://maven.acme.local/maven')
@Grapes({ // <.>
		@Grab(group="org.codehaus.groovy", module="groovy", version="2.5.8"), // <.>
		@Grab(module = "log4j", group = "log4j", version = "1.2.17")
})
class classpath_example {

	static final Logger logger = Logger.getLogger(classpath_example.class);

	public static void main(String[] args) {
		BasicConfigurator.configure();
		Arrays.asList(args).forEach(arg -> out.println(arg));
	}
}
----
<.> Import needed to make the compiler be okey with `@Grab` annotation.
<.> Using `GrabResolver` to enable `mavenCentral` and custom `acme` repository
<.> In Groovy you normally put `@Grab` on import statements. That is not allowed in Java thus when having multiple imports you need to put them in a `@Grapes` annotation first.
<.> `jbang` will grab any `@Grab` annotation and assume it is declaring dependencies.

=== System properties and Environment variables

In dependencies you can refer to environment and system properties to parameterize the dependencies.
It uses the format `${[env.]propertyname:<defaultvalue>}`.

Furthermore to align with properties commonly used to make dependency resolution portable
`jbang` exposes properties similar to what the `https://github.com/trustin/os-maven-plugin[os-maven-plugin]` does.
Plus for ease of use for javafx dependencies it also setups a property named `${os.detected.jfxname}`.

Examples:

[source,bash]
----
${env.USER} = 'max'
${os.name} = 'Mac OS X'
${non.existing.key:empty} = 'empty'
${os.detected.jfxname} = 'mac'
----

This can be put to use in `//DEPS` like so:

  //DEPS org.openjfx:javafx-graphics:11.0.2:${os.detected.jfxname}

Here we use the properties to avoid hardcoding your script to a specific operating system.

=== JavaFX

If `jbang` detects you have a `javafx-` dependency in your list of dependencies
it will if you `java` command supports Java modules automatically set the necessary
`--module-path` and `--add-modules`.

See `link:examples/jfx.java[]` and `link:examples/jfxtiles.java[]` for examples of this.

== Multiple source files (Experimental)

Since version 0.46 there is now initial support for having multiple source files. The main script file defines all the
dependencies and you add more source files into the application using `//SOURCES <filename>`.

The listed file name(s) gets added to source list when compiling.

Currently there are not `*.java` style matching or support for these `.java` files to declare `//DEPS` or other jbang configuration.
That will currently only be honored by the main script/app. These will be loosen up in future based on feedback.

== Adding additional resources (Experimental)

If you want to add a `META-INF/application.properties` or `META-INF/resource.index.html` or other files to the generated jar
you can use `//FILES` to add them.

The format is `//FILES <mountpoint>[=<sourcefile>]`.

Example:

  //FILES resource.properties
  //FILES META-INF/resources/index.html=index.html

Here `resource.properties` will be copied as is and `META-INF/resources/index.html` gets its content from `index.html`.

All locations are relative to the script location.

WARNING: Currently `jbang edit` and http(s) based script do not work with `//FILES`. Will be added later.

== Extension-less/non-java files for cli-plugins

You can use `jbang` to write plugins for cli's like `kubectl`, `git`, etc.
They expect their plugins to be named like `<cmd>-<plugin>`, i.e. `kubectl-myplugin`.

Furthermore some of them, particularly `kubectl` currently require the file to start with `#!` otherwise you get a `exec format error`.

`jbang` has a bit of auto-magic to help in both cases.

=== Kebab casing of filename

`jbang` lets you name your file without a `.java` or `.jsh` extension, such
as `kubectl-my-plugin`. `jbang` will in this case copy the file to a temporary
directory using kebab-case to map the name to a proper java class name.

For example, if you make a file called `kubectl-my-plugin` then `jbang` will assume the actual class name to launch
to be `KubectlMyPlugin`.

Note, similar is done when using `jbang edit`, here the symbolic link will be made so the IDE will treat it as
regular camel cased java class.

NOTE: If you do not follow this naming pattern you will get a compile error as `javac` expects both the public class and file names to be equal.


=== she-bang auto-stripped

For extension less scripts, you can put `#!' header at the beginning to let apps recognize
it is to be treated as a script. To avoid issues when compiling, `jbang` will remove
that line before compilation.

For now this is required for `kubectl` plugin but not `git`. https://github.com/kubernetes/kubectl/issues/822[Issue opened] on this limitation.

== Java version

`jbang` will by default use `JAVA_HOME` and if not available, check the `PATH` to locate the `java` executable to run the script with.

If your script requires a specific or minimal version of Java you can use `//JAVA <version>(+)`.

If Jbang finds a java executable using `JAVA_HOME` or `PATH` which satisfies the stated java version jbang will use it.
If no such version is found it will automatically download and install it.

Examples:

`//JAVA 11` will force use of Java 11. +
`//JAVA 13+` will require at least java 13. Java 13 or higher will be used.

In case no matching `java` is found `jbang` will fail.

You can always force running with specific version of `java` using `--java` command line option, i.e.
`jbang --java 8 hello.java`

== Managing JDKs

In the previous section it was mentioned that Jbang will automatically download and install JDKs when necessary.
You can use the `jdk` command to manage JDKs, for example you can run the following:

  jbang jdk list

which will list all the JDKs that are currently installed by Jbang.

It's easy to `install` additional JDKs by running:

  jbang jdk install 14

which will download and install JDK version 14 into Jbang's cache (`~/.jbang/cache/jdks` by default).
The list of versions that are available for installation can be found here: https://adoptopenjdk.net/releases.html

The first JDK that gets installed by Jbang will be set as the "default" JDK. This is from then on the JDK that will be
used by Jbang if no Java could be found on the system (meaning `javac` wasn't found on the `PATH` and no `JAVA_HOME` is set).
You can change the default JDK by running:

  jbang jdk default 12

Running it without an argument will return the version of the JDK that is currently set as the default.

NOTE: On Windows you might need elevated privileges to create symbolic links. If you don't have permissions then
running the above command  will result in an error. To use it https://stackoverflow.com/a/24353758[enable symbolic links]
for your user or run your shell/terminal as administrator to have this feature working.

When you `uninstall` a JDK by running:

  jbang jdk uninstall 12

and that JDK was set as the default, Jbang will set the next higher version JDK as the default. If no higher version is
available it will select the next lower version.

+== Using managed JDKs yourself

Given the fact that Jbang is able to easily download and install JDKs we thought that it might be a good option for
our users to be able to access those JDKs for their own use instead of having to install yet another version themselves.

To make that easy we added a couple of useful commands. The first can be used to set retrieve to location where the JDK
is installed:

  jbang jdk home

This will return the path to the "default" JDK (by default `~/.jbang/currentjdk)`, if you want to know the location of a
specific JDK you can pass the version as an argument: `jbang jdk home 14`. This command could be used by scripts to find
a JDK to use to run a Java program for example (eg: `JAVA_HOME=$(jbang jdk home)`.

For setting up your current command line environment there's something simpler. You can run:

  jbang jdk java-env

On Linux and Mac this will output something like:

[source]
----
export PATH="/home/user/.jbang/currentjdk/bin:$PATH"
export JAVA_HOME="/home/user/.jbang/currentjdk"
# Run this command to configure your shell:
# eval $(jbang jdk java-env)
----

And the output itself shows how to properly use it to configure your command line to use the JDK. In this case it's by
running:

  eval $(jbang jdk java-env)

To do this by default for all shells you start simply add the above line to your `~/.bashrc` file.

Unfortunately on Windows using CMD things are not as easy as is show by the output of `jbang jdk java-env` on that  platform:

[source]
----
set PATH=C:\Users\user\.jbang\currentjdk\bin;%PATH%
set JAVA_HOME=C:\Users\user\.jbang\currentjdk
rem Copy & paste the above commands in your CMD window or add
rem them to your Environment Variables in the System Settings.
----

Instead of copying and pasting lines you could also redirect the output to a .bat file and execute that instead:

  > jbang jdk java-env > setenv.bat
  > setenv

== Editing

You can edit your script in your IDE by using `jbang edit helloworld.java`. This will generate a project in a temporary location with symbolic links to your script
and output the generated folder name. The easiest way to use that is to use it in a call to your IDE:

[source, bash]
----
code `jbang edit helloworld.java`
----

If you add additional dependencies to your file just re-run the edit command and the relevant files will be regenerated with the updated dependencies.

Above does require using a shell that allows for variable evaluation, if you are on i.e. Windows then you might prefer using:

[source, bash]
----
jbang --open=[editor] helloworld.java
----

The editor used will be what is specified as argument to `--open` or default to `$JBANG_EDITOR`, `$VISUAL` or `$EDITOR` in that order.

NOTE: On Windows you might need elevated privileges to create symbolic links. If you don't have permissions then
the `edit` option will result in an error. To use it https://stackoverflow.com/a/24353758[enable symbolic links]
for your user or run your shell/terminal as administrator to have this feature working.

=== Live Editing

You can also use `jbang edit --live` and `jbang` will launch your editor while watching
for file changes and regenerate the temporary project to pick up changes in dependencies.


=== IDE and Editor support

The `edit` feature been tested with the following IDE's:

:sicons: https://simpleicons.org/icons
.IDE's and Editors tested with `jbang`
[width=75%,frame=none,grid=none]
|===
|image:{sicons}/visualstudiocode.svg[50,50] https://code.visualstudio.com[Visual Studio Code]
|image:{sicons}/eclipseide.svg[50,50] https://www.eclipse.org/downloads/download.php[Eclipse]
|image:{sicons}/intellijidea.svg[50,50] https://www.jetbrains.com/idea/download[IntelliJ Idea]
|image:{sicons}/apachenetbeanside.svg[50,50] https://netbeans.apache.org/download/[Apache NetBeans]
|image:{sicons}/neovim.svg[50,50] https://github.com/neovim/neovim/wiki/Installing-Neovim[Neovim] w/ https://spacevim.org/use-vim-as-a-java-ide/[spacevim Java]
|image:{sicons}/gnuemacs.svg[50,50] https://www.gnu.org/software/emacs/[Emacs] w/ https://www.spacemacs.org[Spacemacs Java]
|===

The `edit` feature works with various IDE's - it generates a `build.gradle` to use with IDE's that understands Gradle directly.
For speed and consistency `jbang` also generates IDE specific settings.

Currently launchers and project files are generated for Eclipse and vscode. Intellij just reads `build.gradle` for now thus
to run/debug you will need to manually set it up.

== Debugging

When running `.java` scripts with `jbang` you can pass the `--debug`-flag and the script will enable debug,
suspend the execution and wait until you connect a debugger to port 4004.

[source, bash]
----
jbang --debug helloworld.java
Listening for transport dt_socket at address: 4004
----

You can change the debug port and host by passing in a interface pattern and number to the debug argument, i.e. `--debug=*:4321`.

This will make it use port 4321 and make it listen on all ('*') network interfaces.

NOTE: Be sure to put a breakpoint in your IDE/debugger before you connect to make the debugger actually stop when you need it.

=== Debug jbang it self

Java itself will add `JAVA_TOOL_OPTIONS` which will apply to `jbang` too.

For finer and more explicit control the scripts, `jbang` will add `JBANG_JAVA_OPTIONS` to the call to `jbang` itself.
Thus if you want to enable debug or other details for `jbang` set that environment variable.

== Flight Recorder

Flight recorder is a feature of the Java VM that lets you gather diagnostic and profiling data about your script.

You can use `//JAVA_OPTIONS` to have full control over it; but for the easiest setup `jbang` lets you just run with `--jfr`, i.e.

  jbang --jfr myapp.java

By default `--jfr` will start flight recorder and tell it to dump event recordings to `myapp.jfr` (i.e. using base name of the script as its filename).

Then you can use tools like `jvisualvm` or `jmc` to explore the data.

If you want to tweak the configuration you can pass flight recorder options, like `jbang --jfr=filename={baseName}.jfr,maxage=24h` where `{baseName}` will be replaced
by the filename and then added `maxage=24h` to flight recording options.

If you want further control use `//JAVAC_OPTS -XX:StartFlightRecording=<your options>` instead.

== `java` and `javac` Options

If you want to tweak memory settings or enable preview features you can setup the necessary options using
`//JAVA_OPTS` and `//COMPILER_OPTS` as in the following example using Java 14 experimental `record` feature:

[source, java]
----
///usr/bin/env jbang "$0" "$@" ; exit $?
//JAVAC_OPTIONS --enable-preview -source 14 <.>
//JAVA_OPTIONS --enable-preview // <.>

import static java.lang.System.*;

public class records {

    record Point(int x, int y) {}

    public static void main(String[] args) {
        var p = new Point(2,4);
        out.println(p);
    }
}
----

Since Java 9 https://docs.oracle.com/javase/9/tools/java.htm#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE__USINGTHEJDK_JAVA_OPTIONSLAUNCHERENV-F3C0E3BA[JDK_JAVA_OPTIONS] and https://docs.oracle.com/javase/9/tools/javac.htm#GUID-AEEC9F07-CB49-4E96-8BC7-BCC2C7F725C9\_\_USINGJDK_JAVAC_OPTIONSENVIRONMENTVA-F3C76845[JDK_JAVAC_OPTIONS] are also picked up by the Java runtime and compiler automatically.

For Java 8 and if you want to set explicitly only for `jbang` you can also add flags by setting `JBANG_JAVA_OPTIONS` and `JBANG_JAVAC_OPTIONS` respectively.

=== (Experimental) Application Class Data Sharing

If your scripts uses a lot of classes Class Data Sharing might help on your startup. The following requires Java 13+.

Using `--cds` jbang will build the jar with Application Class Data Sharing enabled and when run have it load shared class data.

You can put `//CDS` in the java file to enable it by default, or simply use `--cds` to force it or `--no-cds` to turn it off no matter what the jbang script file contains.

== Aliases

To avoid remembering long paths and to enable easy launch of jbang scripts there is an `alias` command
to setup and manage aliases to actual scripts.

  jbang alias add hello https://github.com/jbangdev/jbang-examples/blob/master/examples/helloworld.java

will add an alias named `hello` pointing to that github url which then can be run using `jbang hello`.

  jbang alias list

will show you all the aliases that are defined locally.

=== Implicit Alias Catalogs

The aliases you create are stored locally (see <<Local Alias Catalogs>>), but Jbang can also use remote catalogs.
You can access to catalogs explicitly (see <<Catalogs>>) but much easier to use are what we call "implicit catalogs".
They are aliases that have a special where Jbang is smart enough to know where to find their definition.

Examples:

`jbang hello@jbangdev` will run the alias `hello` as defined in `jbang-catalog.json` found in https://github.com/jbangdev/jbang-catalog.

This allows anyone to provide a set of jbang scripts defined in their github, gitlab or bitbucket repositories.

The full format is `<alias>@<user/org>(/repository)(/branch)(~path)` allowing you to do things like:

.Implicit Catalog Examples:
|====
|Command | Description

|`jbang hello@acme`
|`hello` alias found in `acme/jbang-catalog/jbang-catalog.json` searched on github, gitlab and bitbucket in that order.

|`jbang hello@acme/mycatalog`
|`hello` found in `acme/mycatalog/jbang-catalog.json` searched on github, gitlab and bitbucket in that order.

|`jbang hello@acme/mycatalog/dev`
|`hello` found in `acme/mycatalog/jbang-catalog.json` in the `dev` branch searched on github, gitlab and bitbucket in that order.

|`jbang hello@acme~experimental`
|`hello` found in `acme/jbang-catalog/experimental/jbang-catalog.json`

|====

=== Local Alias Catalogs

Jbang will also look in the current directory for a `jbang-catalog.json` file and if it exists it will look up any aliases in there too.
In fact it will look in several places in the following order:

 1. Current directory, `./jbang-catalog.json`
 2. In `.jbang/jbang-catalog.json`
 3. In the parent directory, `../jbang-catalog.json`
 4. In the parent's `.jbang` directory, ../.jbang/jbang-catalog.json`
 5. And repeating steps 3 and 4 recursively upwards to the root of the file system
 6. As the last step it will look in `$HOME/.jbang/jbang-catalog.json`

When you create aliases using `jbang alias add` the _same_ ordering will be used to determine where to store the alias.
This will only take into account _existing_ files! So if no `jbang-catalog.json` file exists in the local directory it
will _not_ be created for you, but Jbang will keep looking until it finds a file to use (as a last option it will
always be written to `$HOME/.jbang/jbang-catalog.json`).

This means that if you want to write the alias to `jbang-catalog.json` in your local folder you will either have to create
the file first (eg by running `touch jbang-catalog.json`) or by explicitly specifying the file location:

  jbang alias add -f jbang-catalog.json hello https://github.com/jbangdev/jbang-examples/blob/master/examples/helloworld.java

Btw, the flag `--show-origin` is very useful when listing aliases to find out where exactly an alias is defined:

  jbang alias list --show-origin

== Catalogs

Catalogs are lists of Aliases as defined in the previous section, but while the `alias` command is used to manage aliases within a
catalog, the `catalog` command is for managing references to catalogs. This is mostly useful when dealing with remote catalogs.
You can for example add a catalog like this:

  jbang catalog add demo https://github.com/jbangdev/jbang-catalog/blob/master/jbang-catalog.json

The aliases in that catalog are now available by adding `@demo` to their names. For example:

  $ jbang alias list demo
  env@demo = Dump table of Environment Variables
  gavsearch@demo = Search search.maven.org for maven artifacts.
  hello@demo = Script that says hello back for each argument
  properties@demo = Dump table of System properties
  $ jbang run hello@demo World!
  [jbang] Building jar...
  Hello World!

You can list the available catalogs by running:

  jbang catalog list

NB: The output will not only show the catalogs you defined yourself but also the ones that get added implicitly when
running aliases as described in the section <<Implicit Alias Catalogs>>.

== Bash/Zsh auto-completion

If you are using bash or zsh in your terminal you can get auto-completion by running the following:

[source, bash]
----
source <(jbang completion)
----

== Caching

In previous versions of `jbang`, Java 10+ direct launch of `.java` was used, but since v0.6 `jbang` works with Java 8 and thus it
needs to do a separate compile step. Besides now working with Java 8 this also allows to cache the compiled script and thus
launch faster on consecutive runs.

The caching goes to `~/.jbang/cache` by default, you can run `jbang cache clear` to remove all cache data from this folder.

== Build Integration [EXPERIMENTAL]

While `jbang` prepares and builds the underlying jar used for launch there is since v0.40 (for now) experimental API allowing
user included dependencies to influence the generated jar and possible native image.

An example use case enabled by this is to have full Quarkus integration, `jbang quarkuscode.java` will have Quarkus participate to perform its build time optimizations rather than doing it at runtime every time.

It works as following:

Before the jar is created `jbang` will scan the classpath for `META-INF/jbang-integration.list`.
Any classes listed in this file will be loaded and jbang will expect and call the following method on these classes:

[source,java]
----
/**
*
* @param param build dir directory which will be made into a jar when build is done
* @param pomFile location of pom.xml representing the projects dependencies
* @param dependencies list of GAV to Path of artifact/classpath dependencies
* @param nativeImage true if --native been requested
* @return Map<String, Object> map of returns; special keys are "native-image" which is a and "files" to
*          return native-image to be run and list of files to get written to the output directory.
*
*/
Map<String, Object> postBuild(Path builddir, Path pomFile, List<Map.Entry<String, Path>> dependencies,
            boolean nativeImage)
----

Still very experimental and bound to change. Example of its use can be found in https://github.com/quarkusio/quarkus/pull/11542[Quarkus].

== FAQ

[qanda]
Why the name j'bang?::
  I was reading up on how to use the new shebang (#!) feature support in Java 10 and came up with the idea of port `kscript` to Java and needed a name.
From there came j'bang which is a "bad" spelling of how shebang is pronounced in French.

Why use gradle resource locators rather than ?::
  kscript used it and it's nice as it is a one-liner and easily parsable.

How does this compare to ?::
After doing `jbang` I've learned about similar projects and thought it would be nice with some comparison;
+
https://github.com/scijava/jgo[jgo]: an alternative way to launch jars using maven coordinates. Implemented in python, depends on Java and Maven to be available. Not really for scripting but a novel way to launch java apps already packaged as a maven dependency.
+

Why would I use Java to write scripts ? Java sucks for that... Use groovy, kotlin, scala, etc. instead!::
  Well, does it really suck ? With Java 8 streams, static imports and greatly improved standard java libraries it is very close to what kscript and grape look like.
With the following advantages:
+
* works with plain Java without installing additional compiler/build tools
* all IDE's support editing .java files very well, content assist, etc.
* great debugging
+
And to be honest I built `jbang` just to see if I could and get my Java skills refreshed for the newer features in the language.
Use it at your own risk :)

Why not use normal shebang(`#!`) in the header ?::
  You can use normal shebang (`#!/usr/bin/env jbang`) and Java 10+ will actually work with it from the command line. Not recommended though as
many tools and especially IDE's will start complaining about syntax errors as they don't ignore the first line in this case.
+
By using the `//` form it is treated as both a bash/shell file AND a valid java file and thus works everywhere a java file will work.
+
It's worth noting that Go https://golangcookbook.com/chapters/running/shebang/[uses a similar approach] which is also where I learned it from.

== Thanks

`jbang` was heavily inspired by how `https://github.com/holgerbrandl/kscript[kscript]` by Holger Brand works.

