import org.gradle.crypto.checksum.Checksum

plugins {
	id "distribution"
	id "com.github.johnrengelman.shadow" version "8.0.0"
	id "java"
	id "jvm-test-suite"
	id "com.github.breadmoirai.github-release" version "2.4.1"
	id "io.toolebox.git-versioner" version "1.6.7"
	id 'org.gradle.crypto.checksum' version '1.4.0'
	id "com.diffplug.spotless" version "7.2.1"
	id 'com.github.gmazzo.buildconfig' version "3.1.0"
	id "com.dorongold.task-tree" version "2.1.1"
	id "com.geoffgranum.gradle-conventional-changelog" version "0.3.1"
	id "org.asciidoctor.jvm.convert" version "3.3.2"
	id "org.ajoberstar.grgit" version "4.1.1"
	id "org.sonarqube" version "4.0.0.2929"
	id 'jacoco'
	id 'maven-publish'
	id 'io.qameta.allure-report' version '2.12.0'
	id "io.qameta.allure-adapter-base" version "2.12.0"
}

def allureVersion = '2.29.1'
def aspectJVersion = '1.9.25'
def assertjVersion = '3.24.2'
def devkitmanVersion = '0.3.3'
def junitBomVersion = '5.14.1'
def testcontainersVersion = '2.0.2'
def jlineVersion = '3.30.5'
def wiremockVersion = '3.13.2'

configurations {
	agent {
		canBeResolved = true
		canBeConsumed = true
	}
}

javadoc {
	options.encoding = 'UTF-8'
	//remove this to see all the missing tags/parameters.
	options.addStringOption('Xdoclint:none', '-quiet')
}

repositories {
	mavenCentral()
	mavenLocal()
	//maven { url 'https://jitpack.io' }
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(11)
		vendor = JvmVendorSpec.ADOPTIUM
	}
	withJavadocJar()
	withSourcesJar()
}

// Configure toolchain for test execution (separate from compilation)
// Can be set via -PtestJavaVersion=<version> and -PtestJavaVendor=<vendor>
// Example: ./gradlew test -PtestJavaVersion=17 -PtestJavaVendor=adoptium
def testJavaVersion = project.hasProperty('testJavaVersion')
	? JavaLanguageVersion.of(project.property('testJavaVersion') as Integer)
	: JavaLanguageVersion.of(11)
def testJavaVendor = project.hasProperty('testJavaVendor')
	? JvmVendorSpec.matching(project.property('testJavaVendor') as String)
	: JvmVendorSpec.ADOPTIUM

def testExecutionToolchain = project.javaToolchains.launcherFor {
	languageVersion = testJavaVersion
	vendor = testJavaVendor
}


// See https://docs.gradle.org/current/dsl/org.gradle.api.reporting.ReportingExtension.html
// Extension is provided via Gradle's `reporting-base` plugin
reporting {
	baseDir = "$buildDir/reports"
}

allure {
	version.set("2.33.0")
	report {

		// There might be several tasks producing the report, so the property
		// configures a base directory for all the reports
		// Each task creates its own subfolder there
		reportDir.set(project.reporting.baseDirectory.dir("allure-report"))

		// Enable single file generation to open without serving.
		singleFile = true
	}
}

publishing {
	publications {
		maven(MavenPublication) {
			groupId = 'dev.jbang'
			artifactId = 'jbang.bin'

			from components.java

			pom {
				name = 'JBang CLI'
				description = 'JBang Command Line Interface'
				url = 'https://jbang.dev'
				inceptionYear = '2019'
				licenses {
					license {
						name = 'MIT'
						url = 'https://github.com/jbangdev/jbang/blob/main/LICENSE'
					}
				}
				developers {
					developer {
						id = 'maxandersen'
						name = 'Max Rydahl Andersen'
					}
					developer {
						id = 'quintesse'
						name = 'Tako Schotanus'
					}
				}
				scm {
					connection = 'scm:git:https://github.com/jbangdev/jbang'
					developerConnection = 'scm:git:https://github.com/jbangdev/jbang'
					url = 'http://github.com/jbangdev/jbang'
				}
			}
		}
	}

	repositories {
		maven {
			url = layout.buildDirectory.dir('staging-deploy')
		}
	}
}

sourceSets {
	java9 {
		java {
			srcDirs = ['src/main/java9']
			destinationDirectory.set(file('build/classes/java/main'))
		}
	}
}
sourceSets.main.compileClasspath += sourceSets.java9.output.classesDirs;

dependencies {
	implementation "dev.jbang:devkitman:${devkitmanVersion}"

	implementation 'org.jspecify:jspecify:1.0.0'
	implementation 'org.apache.commons:commons-text:1.11.0'
	implementation 'org.apache.commons:commons-compress:1.27.1'
	implementation 'info.picocli:picocli:4.7.7'
	annotationProcessor 'info.picocli:picocli-codegen:4.7.7'
	implementation 'io.quarkus.qute:qute-core:1.13.7.Final'
	implementation 'org.codehaus.plexus:plexus-java:1.2.0'
	implementation 'com.google.code.gson:gson:2.13.2'
	implementation 'org.jsoup:jsoup:1.17.1'
	implementation 'org.codejive:java-properties:0.0.7'

	implementation "org.slf4j:slf4j-nop:1.7.36"
	implementation "org.slf4j:jcl-over-slf4j:1.7.36"
	implementation "org.jboss:jandex:2.2.3.Final"

	implementation "eu.maveniverse.maven.mima:context:2.4.36"
	runtimeOnly    "eu.maveniverse.maven.mima.runtime:standalone-static:2.4.36"
	implementation "org.apache.maven:maven-model:3.9.11"

	implementation "org.jline:jline-console-ui:$jlineVersion"
	implementation "org.jline:jline-terminal-jni:$jlineVersion"

	implementation "eu.maveniverse.maven.nisse:core:0.6.2"
	implementation "eu.maveniverse.maven.nisse.sources:os-source:0.6.2"

	testImplementation platform("org.junit:junit-bom:${junitBomVersion}")
	testImplementation "org.junit.jupiter:junit-jupiter"
	testImplementation "org.junit.platform:junit-platform-launcher"
	testImplementation "com.github.stefanbirkner:system-rules:1.17.2"
	testImplementation "org.assertj:assertj-core:${assertjVersion}"
	testImplementation "org.hamcrest:hamcrest-library:2.2"
	testImplementation "org.wiremock:wiremock:${wiremockVersion}"
	testImplementation platform("io.qameta.allure:allure-bom:$allureVersion")
	testImplementation "io.qameta.allure:allure-junit5"
	// only for test running
	agent "org.aspectj:aspectjweaver:$aspectJVersion"

	allureRawResultElements(files("$buildDir/allure-results"))

}

buildConfig {
	packageName("dev.jbang.util")
	buildConfigField('String', 'NAME', "\"${project.name}\"")
	buildConfigField('String', 'VERSION', provider { "\"${project.version}\"" })
}

// to enable parallel test execution
tasks.withType(Test).configureEach {
	//environment "JAVA_HOME", "/Users/manderse/.local/share/mise/installs/java/graalvm-community-25.0.1"
	//executable = new File("/Users/manderse/.local/share/mise/installs/java/graalvm-community-25.0.1/bin/java")
	//maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
}

// to enable reproducible builds
tasks.withType(AbstractArchiveTask) {
	preserveFileTimestamps = false
	reproducibleFileOrder = true
}

sonarqube {
	properties {
		property "sonar.projectKey", "jbangdev_jbang"
		property "sonar.organization", "jbangdev"
		property "sonar.host.url", "https://sonarcloud.io"
	}
}

spotless {
	lineEndings 'UNIX'
	format 'misc', {
		target '**/*.gradle', '**/*.md', '**/.gitignore'
		targetExclude 'CONTRIBUTORS.md', 'src/main/scripts/container/README.md', 'build/**/*', 'out/**/*'
		// all-contributor bot adds non-indented code
		trimTrailingWhitespace()
		leadingSpacesToTabs(4)
		endWithNewline()
	}
	java {
		importOrder 'java', 'javax', 'org', 'com', 'dev.jbang', ''
		removeUnusedImports()
		eclipse().configFile "misc/eclipse_formatting_nowrap.xml"
		targetExclude 'build/**/*'
	}
	format 'xml', {
		targetExclude 'build/test-results', fileTree('.idea')
		target '**/*.xml', '**/*.nuspec'
	}
}

versioner.apply()

task versionTxt() {
	doLast {
		new File(project.buildDir, "tmp/version.txt").text = project.version
	}
}

def commonSpec = project.copySpec {
	from('examples') {
		include '**/*.java'
		into 'examples'
	}
	from(shadowJar) {
		into 'bin'
	}
	from(project.buildDir.toPath().resolve('tmp')) {
		include 'version.txt'
	}
	from('src/main/scripts') {
		include 'jbang'
		include 'jbang.cmd'
		include 'jbang.ps1'
		into 'bin'
	}
	// Conditionally include native image binary if it exists
	def nativeExecName = getNativeExecutableName()
	if (project.file("${project.buildDir}/native-image/${nativeExecName}").exists()) {
		from(project.buildDir.toPath().resolve('native-image')) {
			include nativeExecName
			into 'bin'
		}
	}
}

distributions {
	main {
		contents {
			with commonSpec
		}
	}
	latest {
		contents {
			with commonSpec
		}
	}
}

latestDistZip {
	archiveFileName = "${project.name}.zip"
}


latestDistTar {
	archiveFileName = "${project.name}.tar"
}

jar {
	manifest {
		attributes(
			'Main-Class': 'dev.jbang.Main',
			'JBang-Version': project.version
		)
	}
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

compileJava {
	options.encoding = 'UTF-8'
	options.compilerArgs << "-Xlint:deprecation"
	options.compilerArgs << '-parameters' // for allure reporting
	options.compilerArgs.addAll(['--release', '8'])
}

compileTestJava {
	options.encoding = 'UTF-8'
	options.compilerArgs << "-Xlint:deprecation"
	options.compilerArgs << '-parameters' // for allure reporting
	options.compilerArgs.addAll(['--release', '11']) // wiremock requires java 11
}

compileJava9Java {
	sourceCompatibility = 9
	targetCompatibility = 9
	options.encoding = 'UTF-8'
	options.compilerArgs << "-Xlint:deprecation"
	options.compilerArgs << '-parameters' // for allure reporting
	options.compilerArgs.addAll(['--release', '9'])
}

shadowJar {
	/*minimize() {
		//exclude(dependency('org.slf4j:slf4j-api:.*'))
		exclude(dependency('dev.jbang:devkitman:.*'))
		exclude(dependency('eu.maveniverse.maven.mima:context:.*'))
		exclude(dependency('eu.maveniverse.maven.mima.runtime:standalone-static:.*'))
		exclude(dependency('org.slf4j:jcl-over-slf4j:.*'))
		exclude(dependency('org.slf4j:slf4j-nop:.*'))
		exclude(dependency('org.jboss.logging:jboss-logging:.*'))
	}*/
	mergeServiceFiles()
	manifest {
		attributes(
			'Main-Class': 'dev.jbang.Main',
			'JBang-Version': project.version
		)
	}
	archiveFileName = "${archiveBaseName.get()}.${archiveExtension.get()}"
}

test {
	useJUnitPlatform()
	javaLauncher = testExecutionToolchain
	def jvmArgsList = ["-javaagent:${configurations.agent.singleFile}"] // for allure reporting
	if (testJavaVersion.asInt() >= 9) {
		jvmArgsList.addAll([
			"--add-opens", "java.base/java.lang=ALL-UNNAMED",
			"--add-opens", "java.base/java.util=ALL-UNNAMED"
		])
	}
	jvmArgs = jvmArgsList
	//testLogging.showStandardStreams = true

	/*testLogging {
		events "passed", "skipped", "failed"
		exceptionFormat "full"
	}*/
	//timeout.set(Duration.ofSeconds(60))

	jacoco {
		enabled = false
	}

	// Allow disabling WireMock via project property -PdisableWiremock=true
	systemProperty('jbang.test.wiremock.enable', project.findProperty('disableWiremock') == 'true' ? 'false' : 'true')
}

jacoco {
	toolVersion = '0.8.14' // 0.8.14 supports java 25
}

jacocoTestReport {
	afterEvaluate {
		executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")
	}

	reports {
		html.required = true
		xml.required = true
		csv.required = false
	}
}

testing {
	suites {
		test {
			useJUnitJupiter()
		}

		integrationTest(JvmTestSuite) {
			dependencies {
				implementation project()  // todo: shouldn't even need to depend on main code?
				implementation platform("org.junit:junit-bom:${junitBomVersion}")
				implementation "org.junit.jupiter:junit-jupiter"
				implementation "org.junit.platform:junit-platform-launcher"
				implementation "org.assertj:assertj-core:${assertjVersion}"
				implementation 'org.zeroturnaround:zt-exec:1.12'
				implementation platform("io.qameta.allure:allure-bom:${allureVersion}")
				implementation "io.qameta.allure:allure-junit5"
				implementation "org.wiremock:wiremock:${wiremockVersion}"
				implementation "dev.jbang:devkitman:${devkitmanVersion}"
				implementation "org.testcontainers:testcontainers:${testcontainersVersion}"
				implementation "org.testcontainers:testcontainers-junit-jupiter:${testcontainersVersion}"
			}

			sources {
				java {
					srcDirs = ['src/it/java']
					resources.srcDirs = ['src/it/resources']
				}
			}

			targets {
				all {
					testTask.configure {
						javaLauncher = testExecutionToolchain
						shouldRunAfter(test) // todo: push to buildDist?
					}
				}
			}
		}
	}
}

tasks.named('integrationTest') {
	dependsOn("installDist") // todo: move to after buildDist
}

task karateExecute(type: JavaExec) {
	classpath = sourceSets.test.runtimeClasspath
	mainClass = System.properties.getProperty('mainClass')
}

task copyResources(type: Copy) {
	from "${projectDir}/src/main/resources"
	into "${buildDir}/classes/java/main"
}
processResources.dependsOn copyResources


task copyTestResources(type: Copy) {
	from "${projectDir}/itests"
	into "${buildDir}/classes/java/test/itests"
}
processTestResources.dependsOn copyTestResources

task createChecksum(type: Checksum) {
	dependsOn(assembleDist)
	files = files([distZip, latestDistZip, distTar, latestDistTar].outputs.files.flatten())
	outputDir = distZip.destinationDirectory.asFile.get()
	algorithm = Checksum.Algorithm.SHA256
}

task container(type: Copy) {
	dependsOn(createChecksum)
	inputs.property('version', project.version)
	from('src/main/scripts/container/')
	include('*')
	into(buildDir.toString() + '/container')
	doFirst { t ->
		t.filter(org.apache.tools.ant.filters.ReplaceTokens,
				tokens: [
						projectVersion: project.version,
						sha256        : new File(distZip.archiveFile.asFile.get().absolutePath + '.sha256').text
				]
		)
	}
}

task spec(type: Copy) {
	dependsOn(createChecksum)
	inputs.property('version', project.version)
	from('src/main/scripts/spec/jbang.spec')
	into(buildDir.toString() + '/spec')
	doFirst { t ->
		t.filter(org.apache.tools.ant.filters.ReplaceTokens,
				tokens: [
						projectVersion: project.version,
						sha256        : new File(distZip.archiveFile.asFile.get().absolutePath + '.sha256').text
				]
		)
	}
}

task chocolatey(type: Copy) {
	dependsOn(createChecksum)
	inputs.property('version', project.version)
	from('src/main/scripts/choco')
	into(buildDir.toString() + '/choco')
	doFirst { t ->
		t.filter(org.apache.tools.ant.filters.ReplaceTokens,
				tokens: [
						projectVersion: project.version,
						sha256        : new File(distZip.archiveFile.asFile.get().absolutePath + '.sha256').text
				]
		)
	}
}

task copyITests(type: Copy) {
	from "${projectDir}/itests"
	into "${buildDir}/itests"
}

task tag(type: Exec) {
	doFirst {
		println 'Tagging with v' + project.version
		commandLine 'git', 'tag', '-a', 'v' + project.version, '-m', 'v' + project.version
	}
}

versioner {
	startFrom {
		major = 0
		minor = 0
		patch = 1
	}
	pattern {
		pattern = "%M.%m.%p(.%c)"
	}
	git {
		authentication {
			https {
				token = project.hasProperty('github_token') ? getProperty('github_token') : "unknown_github_token"
			}
		}
	}
}

asciidoctor {
	sourceDir = file('.')
	sources {
		include 'readme.adoc'
	}
	outputDir = file('build/docs')
	logDocuments = true
	baseDirFollowsSourceDir()
}

task clidoc(type: Exec) {
	doFirst {
		println 'Generating cli man pages'
		commandLine 'build/install/jbang/bin/jbang', '--cp', 'build/install/jbang/bin/jbang.jar', '--deps','org.eclipse.sisu:org.eclipse.sisu.inject:0.3.5', 'docs/genadoc.java', '-d', 'docs/modules/cli', '--force', 'dev.jbang.cli.JBang'
	}
}

//seems crazy we need versionTxt depend on all dist* but
//didn't find better way yet.
distZip.dependsOn(versionTxt)
distTar.dependsOn(versionTxt)

build.dependsOn(latestDistZip)
build.dependsOn(latestDistTar)
build.dependsOn(copyITests)
build.dependsOn(chocolatey)
build.dependsOn(container)
build.dependsOn(spec)
// clidoc not auto included as it depends on jbang...which isn't built at this time.
//build.dependsOn(clidoc)

compileJava.dependsOn(copyResources);
compileJava.dependsOn(compileJava9Java);
compileTestJava.dependsOn(compileJava9Java);

// Don't know how to tell shadowJar _not_ to depend on this
shadowJar.dependsOn(copyTestResources);

// Function to generate parentSuite value based on environment
def generateParentSuite(boolean isIntegrationTest = false, org.gradle.jvm.toolchain.JavaLanguageVersion testJavaVersion) {
	def parts = []
	parts.add(System.getProperty('os.name'))
	parts.add(System.getProperty('os.arch'))
	parts.add(System.getProperty('java.version'))
	if (isIntegrationTest) {
		parts.add("integration-test")
	} else {
		parts.add("unit-test")
	}
	if (System.getenv('JBANG_USE_NATIVE') == 'true') {
		parts.add("native-image")
	} else {
		parts.add("jvm")
	}
	def javaVersionStr = System.getenv('_JBANG_TEST_JAVA_VERSION')
	if (javaVersionStr == null || javaVersionStr.isEmpty()) {
		javaVersionStr = testJavaVersion.asInt().toString()
	}
	parts.add(javaVersionStr)
	try {
		def grgit = org.ajoberstar.grgit.Grgit.open(dir: project.rootDir)
		def gitSha = grgit.head().id
		if (gitSha != null && !gitSha.isEmpty()) {
			parts.add(gitSha.substring(0, Math.min(7, gitSha.length())))
		}
	} catch (ignored) {
		// No git data available
	}
	return parts.join('-')
}

// Function to get the correct native executable name based on OS
def getNativeExecutableName() {
	def osName = System.getProperty('os.name').toLowerCase()
	if (osName.contains('windows')) {
		return 'jbang.bin.exe'
	} else {
		return 'jbang.bin'
	}
}

// Configure resource processing for test and integrationTest
processTestResources {
	filesMatching('allure.properties') {
		expand([
			parentSuite: generateParentSuite(false, testJavaVersion)
		])
	}
}

processIntegrationTestResources {
	filesMatching('allure.properties') {
		expand([
			parentSuite: generateParentSuite(true, testJavaVersion)
		])
	}
}


//fix implicit dependencies
tasks.named("spotlessXml").configure { dependsOn("compileJava") }
tasks.named("spotlessXml").configure { dependsOn("copyResources") }
tasks.named("spotlessXml").configure { dependsOn("processResources") }
tasks.named("spotlessXml").configure { dependsOn("compileTestJava") }
tasks.named("spotlessXml").configure { dependsOn("copyTestResources") }
tasks.named("spotlessXml").configure { dependsOn("chocolatey") }
tasks.named("spotlessXml").configure { dependsOn("copyITests") }




// Native image build task
task nativeImage(type: Exec) {
	dependsOn shadowJar
	description = "Build native image executable"
	group = "build"

	def jarPath = shadowJar.archiveFile.get().asFile.path
	def nativeExecName = getNativeExecutableName()
	def nativeImageName = "native-image"
	def outputDir = layout.buildDirectory.dir("native-image").get().asFile
	if (System.getProperty("os.name").toLowerCase().contains("windows")) {
		nativeImageName += ".cmd"
	}

	def nativeImageCmd = System.getenv("GRAALVM_HOME") ?
		"${System.getenv('GRAALVM_HOME')}${File.separator}bin${File.separator}${nativeImageName}" :
		"${nativeImageName}"


	// Ensure output directory exists
	doFirst {
		outputDir.mkdirs()
	}

	commandLine nativeImageCmd, "-jar", jarPath, "${outputDir}${File.separator}${nativeExecName}",
				"-H:ConfigurationFileDirectories=${projectDir}/src/native-image/config",
				"-H:+ReportExceptionStackTraces",

				"--enable-https",
				"--exact-reachability-metadata", // https://www.graalvm.org/latest/reference-manual/native-image/metadata/ & https://github.com/oracle/graal/issues/7962
				"--enable-url-protocols=jar", // to allow urlclassloader to scan file. https://github.com/oracle/graal/issues/1956 https://www.graalvm.org/jdk25/reference-manual/native-image/dynamic-features/URLProtocols/
				"-H:-ParseRuntimeOptions" // so -Dkey=value will continue to be passed to jbang



	doFirst {
		println "Building native image from: $jarPath"

		println "Output: ${outputDir}/${nativeExecName}"
		println "Using native-image: $commandLine"
	}

	doLast {
		// If double named (happens on windows) rename it back
			def doubleExeFile = new File(outputDir, nativeExecName + ".exe")
			if (doubleExeFile.exists()) {
				def moved = doubleExeFile.renameTo(new File(outputDir, nativeExecName))
				if (!moved) {
					throw new RuntimeException("Failed to rename ${doubleExeFile} to ${nativeExecName}")
				}
			}
		println "Native image built successfully: ${outputDir}/${nativeExecName}"
	}

	// Define outputs for Gradle's incremental build
	outputs.file("${outputDir}/${nativeExecName}")
}

tasks.named("distTar").configure {
	mustRunAfter(tasks.named("nativeImage"))
}

tasks.named("distZip").configure {
	mustRunAfter(tasks.named("nativeImage"))
}

tasks.named("latestDistTar").configure {
	mustRunAfter(tasks.named("nativeImage"))
}

tasks.named("latestDistZip").configure {
	mustRunAfter(tasks.named("nativeImage"))
}

group = "dev.jbang"

// Generate Allure environment.properties before tests run
task generateAllureEnvironment {
	description = "Generate Allure environment.properties with CI or local metadata"
	group = "verification"

	doLast {
		def env = System.getenv()
		def props = new Properties()
		def allureDir = file("$buildDir/allure-results")
		allureDir.mkdirs()

		if (env['GITHUB_ACTIONS'] == 'true') {
			props.setProperty('CI', 'GitHub Actions')
			props.setProperty('GITHUB_REPOSITORY', env['GITHUB_REPOSITORY'] ?: '')
			props.setProperty('GITHUB_REF', env['GITHUB_REF'] ?: '')
			props.setProperty('GITHUB_REF_NAME', env['GITHUB_REF_NAME'] ?: '')
			props.setProperty('GITHUB_SHA', env['GITHUB_SHA'] ?: '')
			props.setProperty('GITHUB_RUN_ID', env['GITHUB_RUN_ID'] ?: '')
			props.setProperty('GITHUB_RUN_NUMBER', env['GITHUB_RUN_NUMBER'] ?: '')
			props.setProperty('GITHUB_WORKFLOW', env['GITHUB_WORKFLOW'] ?: '')
			props.setProperty('RUNNER_OS', env['RUNNER_OS'] ?: '')
			props.setProperty('RUNNER_ARCH', env['RUNNER_ARCH'] ?: '')
		}
		props.setProperty('OS', System.getProperty('os.name') + ' ' + System.getProperty('os.arch'))
		props.setProperty('Java', System.getProperty('java.version'))
		props.setProperty('User', System.getProperty('user.name'))
		props.setProperty('ProjectVersion', project.version.toString())
		try {
			def grgit = org.ajoberstar.grgit.Grgit.open(dir: project.rootDir)
			props.setProperty('GitBranch', grgit.branch.current().name)
			props.setProperty('GitCommit', grgit.head().id)
		} catch (ignored) {
			// No git data available
		}


		new File(allureDir, 'environment.properties').withOutputStream { os ->
			props.store(os, 'Generated by Gradle')
		}
	}
}

// Ensure environment file exists before tests collect results
tasks.named('test') { dependsOn(generateAllureEnvironment) }
tasks.named('integrationTest') { dependsOn(generateAllureEnvironment) }
